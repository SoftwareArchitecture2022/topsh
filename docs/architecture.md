# Общая структура

CLI состоит из четырех основных блоков: Interpreter, Parser, Executor и Storage. Parser преобразует введенную от пользователя строку в команду (массив команд, если реализованы пайпы), которая передается в Executor. Executor запускает функцию, реализовывающую соответствующую команду, передавая ей потоки ввода, вывода и вывода ошибок, а также аргументы функции в виде строки. Считыванием строки от пользователя и запуском Parser и Executor занимается Interpreter. В Storage хранятся определенные пользователем переменные.

# Диаграмма классов

![Диаграмма классов](diagram/TopSHClassDiagram.jpg?raw=true "Диаграмма классов")

## Interpreter

В цикле считывается строка команды от пользователя, передается парсеру. При возникновении исключения в парсере выводится сообщение об ошибке, текущая команда от пользователя не исполняется, ждем от пользователя следующей команды. Полученный от парсера массив команд передается в Executor. Если Executor вернул код ошибки (пользователь ввел команду exit), выходим из цикла.

## Parser

Парсер отвечает за преобразование введенной от пользователя строки в набор команд (команда -- структура, содержащая имя команды и строку из ее аргументов, разделенных пробелом).
На вход парсеру (функции Parse или ParsePipes, в зависимости от этапа разработки) передается строка, после чего последовательно запускаются функции-фильтры:
1. SplitByDelimeters -- пробегаем по строке, разбиваем ее на подстроки типа RawString по пробельным символам, если встретилась двойная или одинарная кавычка, ищем следующую такую же кавычку и кладем в подстроку получившийся кусок целиком; если дошли до конца и не нашли закрывающей кавычки, кидаем исключение; в конце возвращаем массив из RawString. Класс RawString хранит содержимое строки и флаг (строка в двойных кавычках или в одинарных, строки, не обернутые в кавычки, приравниваются к строкам в двойных кавычках).
2. SubstituteVariables -- для подстрок в двойных кавычках выполняем подстановку, то есть ищем в них символ "$", и в качестве имени переменной [name] берем все следующие за ним символы до пробельного символа или символов "$", "="; после чего заменяем "$[name]" на выражение, полученное из Storage по ключу [name].
3. SplitByPipes -- разбиваем массив подстрок на подмассивы подстрок по знаку пайпа "|".
4. ParseCommands -- каждый из получившихся подмассивов передаем функции ParseCommand, возвращаем получившийся массив команд. Функция ParseCommand ищет в первой подстроке первый символ "=", если он есть, записывает имя команды "=", аргументы -- подстроки до и после знака "="; если знака "=" не нашлось, имя команды -- первая подстрока, остальные подстроки записываются в аргумент через пробел.

Замечания: пробельные символы, а также символы "$" и "=" запрещены в именах переменных; для корректного задания переменной "x=y" вокруг знака равенства не должно стоять пробелов (как в bash); для корректной работы пайпов "cmd1 | cmd2" вокруг знака пайпа должны стоять пробелы (в отличие от bash).

## Executor

### Описание

Executor представляет из себя класс, занимающийся обработкой команд, являющихся результатом парсинга строки ввода.
Executor умеет обрабатывать операции присваивания и вызовы внешних и внутренних программ. Операция присваивания выполняется
соответствующим обработчиком, взаимодействующим со Storage для просмотра и запоминания переменных окружения.  Для операций вызова программ, Executor 
умеет определять, является ли программа внутренней или внешней. Для внутренних команд у Executor имеется связь с обработчиками внутренних команд,
исполняющих требуемый код. Для внешних команд Executor воспроизводит вызов внешней программы средствами ОС. Для работы программ внутри Executor
предусмотрены средства для управления и перенаправления потоков выводов. Также Executor способен запоминать коды возврата программ с целью управления потоком исполнения.

### Фазы имплементации

#### Фаза 1

На первом этапе планируется реализовать возможность Executor исполнять одну единственную команду с сохранением результата, управления I/O, запоминанием кода возврата. Также
планируется реализовать все требуемые встроенные подпрограммы, а также вызовы внешних программ, сохранение переменных окружения.

#### Фаза 2

На втором этапе работы планируется расширить функционал Executor до выполнения команд через pipe-operator - то есть реализовать передачу 
потоков информации между вызываемыми программами, т.е. весь вывод одной программы будет передаваться на вход другой.

## Storage

Storage отвечает за взаимодейтсвия с ОС на предмет работы с переменными окружения. Storage умеет обращаться к системе с запросами присвоения переменной окружения
нового значения или нахождения значения запрашиваемой переменной окружения.
Данный способ выбран потому, что дочерним процессам в любом случае нужна информация о переменных окружения, так что, т.к. поддержка export нам не нужна, мы можем обойтись хранением переменных окружения непосредственно средствами ОС, избегая промежуточных хранилищ.
